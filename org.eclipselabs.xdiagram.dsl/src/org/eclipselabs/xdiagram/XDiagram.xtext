grammar org.eclipselabs.xdiagram.Dsl with org.eclipse.xtext.common.Terminals


import 'http://www.eclipse.org/emf/2002/Ecore' as ecore
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes

generate dsl "http://www.eclipselabs.org/xdiagram/Dsl"


XDiagram:
    'metamodel' importURI=STRING
    imports+=ImportStatement   
     
    diagram=Diagram
    
    groups+=Group*
    
    (
    	(elements += DiagramElement) |
    	(styles += Style) |
    	(colors += CustomColor) |
    	(figures += CustomFigure)
    )*
;


// importedNamespace apparently cannot be on the root element
ImportStatement:
	{ImportStatement}
	('import' importedNamespace=QualifiedNameWithWildCard)?
;

QualifiedName:
  ID ('.' ID)*
;

QualifiedNameWithWildCard returns ecore::EString :
    QualifiedName  ('.' '*')?;
    
Diagram:
	'diagram' modelClass=[ecore::EClass|QualifiedName] '{'
	contains+=Contains*
	figures+=ConnectableElement*
	'}'
;

Group:
	'group' name=ID
;

DiagramElement:
	Node | Link
;


Style:
	'style' name=ID (styled?='extends' style=[Style])? '{'
	      features+=StyleFeature*
	'}'
;




/**
 * Every feature has to be added here, and have:
 * (conditional=FeatureConditional)?
 */
Feature:
		StyleFeature |
		LinkedFeature
;

LinkedFeature returns Feature:
	Contains | 
	Anchor
;

StyleFeature returns Feature:
	Size | Position | Point | Corner |
	Background | Foreground | Transparency |
	FontFace | FontSize | FontStyle | TextValue |
	LineStyle | LineWidth
;

FeatureContainer:
	ConnectableElement | DecoratorElement | Link | Style
;

ChildElement returns FeatureContainer:
	ConnectableElement | Line | Arrow
;

// validate ATT / Value
FeatureConditional:
	'if' modelAttribute=[ecore::EAttribute|QualifiedName] operator=Operator value=Value
;







// TODO validation: unique nodes
// notation inheritance?
Node:
    'node' modelClass=[ecore::EClass|QualifiedName]  '{'
     ('toolname' toolName=STRING (':' group=[Group])?)?  ('icon' imageId=ID)?
    	rootFigure = ConnectableElement
    '}'
;
    
   


// TODO: validation - complex requires source e target, complex structure
// TODO text / icon
Link:
    'link'(
    	(reference?='reference' modelReference=[ecore::EReference|QualifiedName]) | 
    	
    	(complex?='object' modelClass=[ecore::EClass|QualifiedName] 
    	'source' sourceReference=[ecore::EReference|QualifiedName] 
    	'target' targetReference=[ecore::EReference|QualifiedName]
    	)
    )  (toolName=STRING (':' group=[Group])?)?  ('icon' imageId=ID)? 
    '{'
    'connection' type=ConnectionType (styled?='+' style=[Style])? '{'
    	features += LinkFeature*
    	//decorators += Decorator*	
    '}'
    '}'
;
    
 
enum ConnectionType:
	FREE='free' |
	MANHATTAN='manhattan'	
;	

LinkFeature returns Feature:
	Foreground | LineStyle | LineWidth | Decorator
;
    
    
    


// % opcional? ou considerar pixeis?
// ter "constantes" para origem destino
// TODO validation %
// TODO validation children of decorator
Decorator:
	'decorator' position=INT '%' (conditional=FeatureConditional)? element = DecoratorElement
;








// TODO validation
Anchor:
	'anchor' direction=AnchorDirection modelReference=[ecore::EReference|QualifiedName] 
	(conditional=FeatureConditional)?
;


enum AnchorDirection:
	INCOMING='incoming' |
	OUTGOING='outgoing'
;













//---------------------------------------
// Colors


CustomColor:
	'color' name=ID R=INT ',' G=INT ',' B=INT
;

Color:
	(default=DefaultColor) | (custom=[CustomColor])
;


enum DefaultColor:
	WHITE='white' |
	SILVER='silver' |
	GRAY='gray' |
	BLACK='black' |
	RED='red' |
	MAROON='maroon' |
	YELLOW='yellow' |
	OLIVE='olive' |
	LIME='lime' |
	GREEN='green' |
	AQUA='aqua' |
	TEAL='teal' |
	BLUE='blue' |
	NAVY='navy' |
	FUCHSIA='fuchsia' |
	PURPLE='purple'
;






//---------------------------------------
// Connectable Elements
/*
 * Every connectable element must be included here, and have:
 * (composite?='children:' children+=ConnectableElement+)?
 * children+=ChildElement*
 * (styled?='+' style=[Style])?
 */
ConnectableElement:
	Rectangle | Rhombus | Ellipse | Polyline | Label | Image | Invisible | Custom | Triangle
;

DecoratorElement returns FeatureContainer:
	Ellipse | Rhombus | Polyline | Triangle | Label | Image | Arrow | Line
;


//LineElement returns Element:
//	Arrow | Line
//;


ConnectableElementFeature returns Feature:
	Position | Size | ColorFeature | LineStyle | LineWidth | Contains | Anchor | Layout | Visible
;


Layout:
	'layout' layout=ContainerLayout
	(conditional=FeatureConditional)?	
;

Visible:
	'invisible' conditional=FeatureConditional
;


CustomFigure:
	'figure' name=ID 'as' element=ConnectableElement
;





Custom:
	'figure' figure=[CustomFigure] (styled?='+' style=[Style])? '{'
		features+=LinkedFeature*
		children+=ChildElement*
	'}'
;

Rectangle:
	(rectangle?='rectangle' | square?='square') (styled?='+' style=[Style])? '{'
		features+=RectangleFeature*
		children+=ChildElement*
	'}'
;

RectangleFeature returns Feature:
	ConnectableElementFeature | Corner
;

Rhombus:
	{Rhombus}
	'rhombus' (styled?='+' style=[Style])? '{'
		features+=ConnectableElementFeature*
		children+=ChildElement*
	'}'
;

Ellipse:
	(ellipse?='ellipse' | circle?='circle') (styled?='+' style=[Style])? '{'
		features+=ConnectableElementFeature*
		children+=ChildElement*
	'}'
;


Polyline: 
	(polygon?='polygon' | polyline?='polyline') (styled?='+' style=[Style])? '{'
		features+=Point
		features+=Point
		features+=Point*
		features+=ConnectableElementFeature*
		children+=ChildElement*
	'}'
;

Triangle:
	{Triangle}
	'triangle' 	(styled?='+' style=[Style])? '{'
		features+=ConnectableElementFeature*
		children+=ChildElement*
	'}'
;



Line:
	{Line}
	(horizontal?='hline' | vertical?='vline') (styled?='+' style=[Style])? '{'
		features+=LineFeature*
	'}'
;

LineFeature returns Feature:
	LineWidth | Foreground | Position | Size | Visible
;

Arrow:
	{Arrow}
	'arrow' (styled?='+' style=[Style])? '{'
		features+=LineFeature*
	'}'
;










// TODO validation: contains of conflict types
Contains:
'container' modelReference=[ecore::EReference|QualifiedName] 
(conditional=FeatureConditional)?
;


enum ContainerLayout:
	FREE='free' |
	VSTACK='vertical' |
	HSTACK='horizontal'
;

//TODO < > <= =>
enum Operator:
	EQUAL='=' |
	DIFFERENT='<>'
;

// TODO include object type?
Value:
	IntValue | DoubleValue | StringValue | BooleanValue | EnumValue
;

IntValue:
	value=INT
;

DoubleValue:
	valueInt=INT '.' valueDecimal=INT
;

StringValue:
	(null?='null' | value=STRING)
;

BooleanValue:
	value=BooleanLiteral
;

enum BooleanLiteral:
	TRUE='true' |
	FALSE='false'
;

// TODO validation
EnumValue:
	name=ID
;







FigureFeature returns Feature:
	ColorFeature | Size | Position | Point | LineStyle
;


// TODO: validation  at most one editable
Label:
	{Label}
	'label' (styled?='+' style=[Style])? '{'
	features+=LabelFeature*
	children+=ChildElement*
	'}'
;

LabelFeature returns Feature:
	TextValue | Foreground | FontFace | FontSize | FontStyle | Size | Position | Visible
;



Image:
	'image' imageId=ID (styled?='+' style=[Style])? '{'
	features+=ImageFeature*
	children+=ChildElement*
	'}'
;

ImageFeature returns Feature:
	Size | Position | Transparency
;


Invisible:
	{Invisible}
	'invisible' (styled?='+' style=[Style])? '{'
	features+=InvisibleFeature*
	children+=ChildElement*
	'}'
;

InvisibleFeature returns Feature:
	Size | Position | LinkedFeature | Layout
;









ColorFeature:
	Foreground | Background
;

Foreground returns ColorFeature:
	type='foreground' color=Color
	(conditional=FeatureConditional)?
;

Background returns ColorFeature:
	type='background' color=Color
	(conditional=FeatureConditional)?
;


Transparency:
	'transparency' percent=INT '%'
	(conditional=FeatureConditional)?
;





Size:
	'size' width=INT (widthRelative?='%')? ('x' height=INT (heightRelative?='%')?)?
	(conditional=FeatureConditional)?
;

Point:
	'point' x=INT ',' y=INT
	(conditional=FeatureConditional)?
;

// TODO validation: no Position when vstack hstack
Position:
	'position' x=INT (xRelative?='%')? ',' y=INT (yRelative?='%')?
	(conditional=FeatureConditional)?
;

Corner:
	'corner' angle=INT
	(conditional=FeatureConditional)?
;







//--------------------------------
// Text

// TODO: validation of owned attribute
TextValue:
	{TextValue}
	'text' parts+=TextPart*
	(conditional=FeatureConditional)?
;

TextPart:
	text=STRING | modelAttribute=[ecore::EAttribute|QualifiedName]
;

FontFace:
	'font-face' face=FontFaceType
	(conditional=FeatureConditional)?
;

FontSize:
	'font-size' size=INT
	(conditional=FeatureConditional)?
;

FontStyle:
	'font-style' styles+=FontStyleType (',' styles+=FontStyleType)*
	(conditional=FeatureConditional)?
;



enum FontFaceType:
	ARIAL='arial' |
	VERDANA='verdana' |
	TIMES='times' |
	COURIER='courier'
;

enum FontStyleType:
	ITALICS='italics' |
	BOLD='bold' |
	UNDERLINE='underline'
;







//-------------------------------
// Lines


LineStyle:
	'line-type' style=LineType  
	(conditional=FeatureConditional)?
;

enum LineType:
	SOLID='solid' |
	DASH='dashed' |
	DOT='dotted' 
;

LineWidth:
	'line-width' width=INT
	(conditional=FeatureConditional)?
;





//---------------------------------
// Terminals

//terminal PERCENT: ('0'|('1'..'9')(('0'..'9'))?|'100');

//terminal S: (' '|'\t')+;

//terminal NEWLINE:
// New line on DOS or Unix 
//   '\r'? '\n';
    