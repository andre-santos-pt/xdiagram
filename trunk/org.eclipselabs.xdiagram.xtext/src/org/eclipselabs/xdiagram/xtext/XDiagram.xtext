grammar org.eclipselabs.xdiagram.xtext.XDiagram with org.eclipse.xtext.common.Terminals

import 'http://www.eclipse.org/emf/2002/Ecore' as ecore
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes

generate xdiagram "http://www.eclipselabs.org/xdiagram/xtext/XDiagram"

XDiagram:
    'metamodel' importURI=STRING
    imports+=ImportStatement    
    'diagram' modelClass=[ecore::EClass|QualifiedName]
    
    (
    	(nodes += Node) |
    	(links += Link) |
    	(styles += Style) |
    	(colors += CustomColor) |
    	(images += ImageFile)
    )*
;

// importedNamespace apparently cannot be on the root element
ImportStatement:
	{ImportStatement}
	('import' importedNamespace=QualifiedNameWithWildCard)?
;

QualifiedName:
  ID ('.' ID)*
;

QualifiedNameWithWildCard returns ecore::EString :
    QualifiedName  ('.' '*')?;
    

Style:
	'style' ':' name=ID '{'
	      features+=Feature*
	'}'
;

// TODO: common: text / icon / tooltip
DiagramElement:
	Node | Link
;

// resizable default?
// TODO validation: unique nodes
// notation inheritance?
Node:
    'node' modelClass=[ecore::EClass|QualifiedName] 
    '{'
    	 ('set' ':' (resizable?='resizable')?)?
    	 ('style' style=ID)?
    	 ('icon' icon=ID)?
    	 ('name' name=STRING)?
    
    	mainFigure = ConnectableElement
    
    	(attributes += Attribute)*
    	(
//    	(figures += NodeFigure2) |
    	
    //	(containers += NodeContainer) |
		(anchors += Anchor)
		)*
    '}';
    
    
    
// TODO : EMF default value
Attribute:
	'set' key=ID '=' value=AtributeValue
;


// main? s√≥ Figure?
//NodeFigure:
//	'figure' (option=('main'))? ':' element=ConnectableElement (',' 'style' ':' style=ID)?
//;

//NodeFigure:
//	'figure' ':' element=ConnectableElement
//;

// TODO validation
// for passar para figura? so uma figura?
NodeContainer:
	'container'  (layout=ContainerLayout)? ('for' modelReference=[ecore::EReference|QualifiedName])? (':' value=INT format=('%'|'px'))?
	'{'
		(figures += ConnectableElement)+
	'}'
;


// TODO vstack / hstack
enum ContainerLayout:
	STACK='stack' |
	FREE='free'
;


// TODO: validation - complex requires source e target, complex structure
// TODO text / icon
Link:
    'link' (
    	modelReference=[ecore::EReference|QualifiedName] | 
    	
    	(complex?='object' modelClass=[ecore::EClass|QualifiedName] 
    	'source' sourceReference=[ecore::EReference|QualifiedName] 
    	'target' targetReference=[ecore::EReference|QualifiedName]
    	)
    )  
    '{'
    	(manhattan?=('manhattan'))?
    	('style' style=ID)?
    	('icon' icon=ID)?
    	('name' name=STRING)?
    	
    	attributes += Attribute*
    	features += LinkFeature*
	    decorators += Decorator*		    
    '}';
    
    
    

// % opcional? ou considerar pixeis?
// ter "constantes" para origem destino
Decorator:
	'decorator' (('at' position=INT '%')|(source?='source')|(target?='target')|(middle?='middle'))
//	'{'			
		((staticElement = StaticElement) | (label = Label))?			
//	'}'
;

StaticElement returns ConnectableElement:
	 Rhombus | Polyline //| Arrow | Triangle
;





// TODO: model ids / name Anchor
// anchor to?
Anchor:
	'anchor' ('to' object=ID)? ':' (passX=('-'))? X=INT formatX=('%'|'lf'|'rg') ',' (passY=('-'))? Y=INT formatY=('%'|'up'|'dw')
	'{'
		(figures += ConnectableElement)*
		(constraints += AnchorConstraint)*
	'}'
;

// TODO: model ids - change syntax / name AnchorConstraint -- N connections?
AnchorConstraint:
	'for' (type=AnchorConstraintType)? reference=ID ('max' ':' max=INT)?
;

enum AnchorConstraintType:
	INCOMING='<-' |
	OUTGOING='->'
;







Element:
	ConnectableElement | Link
;


// TODO: invisible figure?
ConnectableElement:
	Rectangle | Rhombus | Ellipse | Polyline | Label | Image 
;



RGB:
	R=INT ',' G=INT ',' B=INT
;

ImageFile:
	'image' name=ID src=STRING
;

Color:
	(default=DefaultColor) | (custom=[CustomColor])
;

CustomColor:
	('color' name=ID rgb=RGB)
;


// TODO : 16 standard
enum DefaultColor:
	RED='red' |
	BLUE='blue' |
	YELLOW='yellow'
;


Rectangle:
	(rectangle?='rectangle' | square?='square') '{'
		features+=RectangleFeature*
		children+=ConnectableElement*
	'}'
;

RectangleFeature returns Feature:
	ConnectableElementFeature | Corner
;

Rhombus:
	{Rhombus}
	'rhombus' '{'
		features+=ConnectableElementFeature*
		children+=ConnectableElement*
	'}'
;

Ellipse:
	(ellipse?='ellipse' | circle?='circle') '{'
		features+=ConnectableElementFeature*
		children+=ConnectableElement*
	'}'
;


Polyline: 
	(polygon?='polygon' | polyline?='polyline') '{'
		features+=Point
		features+=Point
		features+=Point*
		features+=ConnectableElementFeature*
		children+=ConnectableElement*
	'}'
;


ConnectableElementFeature returns Feature:
	Position | Size | ColorFeature | LineStyle | LineWidth | Contains
;







/**
 * Every feature has to be added here, and have:
 * (conditional=FeatureConditional)?
 */
Feature:
		Size | Position | Point | 
		Background | Foreground |
		TextValue | FontFace | FontSize | FontStyle | 
		LineStyle | LineWidth | Transparency | Corner 
		| Contains
;

// validate ATT / Value
FeatureConditional:
	'(' modelAttribute=[ecore::EAttribute|QualifiedName] operator=Operator value=Value ')'
;

Contains:
'contains' ':' modelReference=[ecore::EReference|QualifiedName] (conditional=FeatureConditional)?
;

enum Operator:
	EQUAL='=' |
	DIFFERENT='<>'
;

// TODO include object type
Value:
	IntValue | DoubleValue | StringValue | BooleanValue | EnumValue
;

IntValue:
	value=INT
;

DoubleValue:
	valueInt=INT '.' valueDecimal=INT
;

StringValue:
	(null?='null' | value=STRING)
;

BooleanValue:
	value=BooleanLiteral
;

enum BooleanLiteral:
	TRUE='true' |
	FALSE='false'
;

// TODO validation
EnumValue:
	name=ID
;

// enum?
AtributeValue:
	(valueINT=INT) |
	(valueINT=INT '.' valueDEC=INT) |
	(valueID=ID) |
	(valueBOOL=('true'|'false')) |
	(valueSTRING=STRING) |
	(valueDAY=INT '-' valueMONTH=INT '-' valueYEAR=INT)
;







FigureFeature returns Feature:
	ColorFeature | Size | Position | Point | LineStyle
;


// TODO: validation  at most one editable
Label:
	{Label}
	'label' (editable?='editable')? '{'
	features+=LabelFeature*
	children+=ConnectableElement*
	'}'
;

LabelFeature returns Feature:
	TextValue | Foreground | Background | FontFace | FontSize | FontStyle
;



Image:
	'image' image=[ImageFile] '{'
	features+=ImageFeature*
	children+=ConnectableElement*
	'}'
;

ImageFeature returns Feature:
	Size | Position | Transparency
;









//LinkElement:
//	'line' lineType=LineType '{'
//	features+=LinkFeature*
//	'}'
//;

LinkFeature returns Feature:
	Foreground | LineStyle | LineWidth
;


ColorFeature:
	Foreground | Background //| Border
;

Foreground:
	'foreground' ':' color=Color 
	(conditional=FeatureConditional)?
;

Background:
	'background' ':' color=Color
	(conditional=FeatureConditional)?
;

//Border:
//	'border' ':' color=Color
//;

// validation
Transparency:
	'transparency' ':' percent=PERCENT
	(conditional=FeatureConditional)?
;


//Width:
//	'width' ':' width=INT
//;

Size:
	'size' ':' width=INT 'x' height=INT
	(conditional=FeatureConditional)?
;

Point:
	'point' ':' x=INT ',' y=INT
	(conditional=FeatureConditional)?
;

Position:
	'position' ':' x=INT ',' y=INT
	(conditional=FeatureConditional)?
;

Corner:
	'corner' ':' angle=INT
	(conditional=FeatureConditional)?
;


// TODO: validation of owned attribute
TextValue:
	'text' ':' (text=STRING | modelAttribute=[ecore::EAttribute|QualifiedName])
	(conditional=FeatureConditional)?
;

FontFace:
	'font-face' ':' face=FontFaceType
	(conditional=FeatureConditional)?
;

FontSize:
	'font-size' ':' size=INT
	(conditional=FeatureConditional)?
;

FontStyle:
	'font-style' ':' styles+=FontStyleType (',' styles+=FontStyleType)*
	(conditional=FeatureConditional)?
;



enum FontFaceType:
	ARIAL='arial' |
	VERDANA='verdana' |
	TIMES='times' |
	COURIER='courier'
;

enum FontStyleType:
	ITALICS='italics' |
	BOLD='bold' |
	UNDERLINE='underline'
;



LineStyle:
	'line-style' ':' style=LineType
	(conditional=FeatureConditional)?
;

enum LineType:
	SOLID='solid' |
	DASH='dash' 
;

LineWidth:
	'line-width' ':' width=INT
	(conditional=FeatureConditional)?
;


terminal PERCENT: ('0'|('1'..'9')(('0'..'9'))?|'100') '%';



