/*
 * generated by Xtext 2.10.0
 */
package pt.iscte.xdiagram.dsl.scoping

import com.google.common.collect.ArrayListMultimap
import com.google.common.collect.Multimap
import java.util.Collections
import java.util.Map
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.resource.EObjectDescription
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import pt.iscte.xdiagram.dsl.model.ConnectableElement
import pt.iscte.xdiagram.dsl.model.Contains
import pt.iscte.xdiagram.dsl.model.Diagram
import pt.iscte.xdiagram.dsl.model.DiagramElement
import pt.iscte.xdiagram.dsl.model.Link
import pt.iscte.xdiagram.dsl.model.ModelPackage
import pt.iscte.xdiagram.dsl.model.Node
import pt.iscte.xdiagram.dsl.model.XDiagram
import java.util.HashMap
import pt.iscte.xdiagram.dsl.model.Anchor
import pt.iscte.xdiagram.dsl.model.AnchorDirection

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class XdiagramDslScopeProvider extends AbstractXdiagramDslScopeProvider {

	new() {
//		println("SCOPE")
	}

	override getScope(EObject context, EReference reference) {
		return if(reference.EType.getName().matches("EClass|EReference|EAttribute"))
			new XdiagramScope(context, reference)
		else 
			super.getScope(context, reference)	
	}

	static class XdiagramScope implements IScope {
//		var list = new ArrayList<IEObjectDescription>();
		val EObject context;
		val EReference reference;
		var EPackage ePackage;

		new(EObject context, EReference reference) {
			this.context = context;
			this.reference = reference;
			loadEPackage();
			if (ePackage != null)
				loadData();
		}

		def loadEPackage() {
			var xdiagram = crawlUp(context, ModelPackage.Literals.XDIAGRAM) as XDiagram;

			if (xdiagram.metamodel != null && xdiagram.metamodel.plugin != null &&
				xdiagram.metamodel.ecorePath != null) {
				var ecorePlugin = xdiagram.metamodel.plugin;
				var ecorePath = xdiagram.metamodel.ecorePath;
				if (ecorePath.startsWith("/"))
					ecorePath.substring(1);
				var location = ecorePlugin + "/" + ecorePath;

				var modelLocation = URI.createPlatformResourceURI(location, true);
				var rs = new ResourceSetImpl();
				var Resource resource = null;
				try {
					resource = rs.getResource(modelLocation, true);
				} catch (Exception e) {
//					println("FAIL")
					modelLocation = URI.createPlatformPluginURI(location, true);
					try {
						resource = rs.getResource(modelLocation, true);
					} catch (Exception e2) {
//						println("FAIL2")
					}
				}
				if (resource != null)
					ePackage = resource.getContents().get(0) as EPackage;
			}
		}
		
		var Map<QualifiedName, IEObjectDescription> eClassMap = new HashMap();
		var Multimap<QualifiedName, IEObjectDescription> referenceLinksMap = ArrayListMultimap.create();
		var Multimap<QualifiedName, IEObjectDescription> parentChildrenMap = ArrayListMultimap.create();
		var Multimap<QualifiedName, IEObjectDescription> attributesMap = ArrayListMultimap.create();
		var Multimap<QualifiedName, IEObjectDescription> complexRefsMap = ArrayListMultimap.create();
		var Multimap<QualifiedName, IEObjectDescription> complexRefsSourceMap = ArrayListMultimap.create();
		var Multimap<QualifiedName, IEObjectDescription> targetRefsMap = ArrayListMultimap.create();

		var Multimap<QualifiedName, IEObjectDescription> incomingRef = ArrayListMultimap.create();
		var Multimap<QualifiedName, IEObjectDescription> outgoingRef = ArrayListMultimap.create();
		
		def loadData() {
			for (c : ePackage.EClassifiers) {
				if (c instanceof EClass) {
					var eClass = c as EClass;
					var classQname = QualifiedName.create(eClass.name);

					eClassMap.put(classQname, new EObjectDescription(classQname, c, null));
						
					for (a : c.EAllAttributes) {
						var adesc = new EObjectDescription(QualifiedName.create(a.name), a, null);
						attributesMap.put(classQname, adesc);
					}

					for (r : c.EAllReferences) {
						var qname = QualifiedName.create(c.name, r.name)
						var rdesc = new EObjectDescription(qname, r, null);
						referenceLinksMap.put(qname, rdesc);
						
						var iname = QualifiedName.create(r.EType.name, r.name);
						incomingRef.put(QualifiedName.create(r.EType.name), new EObjectDescription(iname,r,null));
						
						outgoingRef.put(classQname, new EObjectDescription(QualifiedName.create(r.name), r, null));
						
						if (r.isContainment) {
							qname = QualifiedName.create(c.name)
							rdesc = new EObjectDescription(QualifiedName.create(r.name), r, null);
							parentChildrenMap.put(qname, rdesc);
							
							for(r_uni : (r.EType as EClass).EAllReferences) {
								if(r_uni.lowerBound == 1 && r_uni.upperBound == 1) {
									var uname = QualifiedName.create(r.EType.name);
									var udesc = new EObjectDescription(uname, r.EType, null);
									complexRefsMap.put(uname, udesc);
									
									var sname = QualifiedName.create(c.name, r.name);
									var sdesc = new EObjectDescription(sname, r, null);
									complexRefsSourceMap.put(uname, sdesc);
								}
							}
						}
						else if(!r.isContainment && r.lowerBound == 1 && r.upperBound == 1) {
							var tdesc = new EObjectDescription(QualifiedName.create(r.name), r, null);							
							targetRefsMap.put(classQname, tdesc);
						}
					}
				}
			}
		}

		def crawlUp(EObject o, EClass clazz) {
			var n = o.eContainer;
			while (!(clazz.isInstance(n)))
				n = n.eContainer;
			return n;
		}

		def getDiagramElement(EObject o) {
			var n = o.eContainer;
			while (!(n instanceof DiagramElement))
				n = n.eContainer;
			return n as DiagramElement;
		}

		override getAllElements() {
			if(context instanceof Diagram || context instanceof Node) {
				 return eClassMap.values.filter[!(EObjectOrProxy as EClass).abstract];
			}
			else if (context instanceof Contains) {
				if (context.eContainer instanceof Diagram) {
					val diagram = context.eContainer as Diagram;
					return parentChildrenMap.get(QualifiedName.create(diagram.modelClass.name));
				} else if (context.eContainer instanceof ConnectableElement) {
					val node = getDiagramElement(context) as Node;
					return parentChildrenMap.get(QualifiedName.create(node.modelClass.name));
				}
			} 
			else if (context instanceof Link && (context as Link).reference) {
				return referenceLinksMap.values;
			}
			else if (context instanceof Link && (context as Link).complex) {
				if(reference.name.equals("modelClass")) {
					return complexRefsMap.values;
				}
				else if (reference.equals(ModelPackage.Literals.LINK__SOURCE_REFERENCE)) {
					var qname = QualifiedName.create((context as Link).modelClass.name);
					return complexRefsSourceMap.get(qname);
				} 
				else if (reference.equals(ModelPackage.Literals.LINK__TARGET_REFERENCE)) {
					var qname = QualifiedName.create((context as Link).modelClass.name);
					return targetRefsMap.get(qname);
				}
			} 
			else if (reference.name.equals("modelAttribute")) {
				var owner = crawlUp(context, ModelPackage.Literals.DIAGRAM_ELEMENT);
				if (owner instanceof Link && (owner as Link).reference) {
					return Collections.emptyIterator() as Iterable<IEObjectDescription>;
				} else if (owner instanceof Node) {
					return attributesMap.get(QualifiedName.create(owner.modelClass.name));
				} else if (owner instanceof Link)
					return attributesMap.get(QualifiedName.create(owner.modelClass.name));
			} 
			else if(context instanceof Anchor) {
				var owner = crawlUp(context, ModelPackage.Literals.NODE) as Node;
				var qname = QualifiedName.create(owner.modelClass.name);
				if(context.direction == AnchorDirection.OUTGOING) {
					return outgoingRef.get(qname);
				}
				else if(context.direction == AnchorDirection.INCOMING) {
					return incomingRef.get(qname);
				}
			}
			else
				return Collections.emptyList;
		}

//TODO
		override getElements(EObject object) {
			return Collections.emptyList();
		}

//TODO
		override getSingleElement(EObject object) {
			return null;
		}

//TODO
		override getElements(QualifiedName name) {
			return Collections.emptyList();
		}

		override getSingleElement(QualifiedName name) {
			if (context instanceof Contains) {
				if (context.eContainer instanceof Diagram) {
					val diagram = context.eContainer as Diagram;
					for (EReference r : diagram.modelClass.EAllContainments) {
						if (r.name.equals(name.toString))
							return new EObjectDescription(name, r, null);
					}
				} else if (context.eContainer instanceof ConnectableElement) {
					var n = context.eContainer;
					while (!(n instanceof Node))
						n = n.eContainer;
					val node = n as Node;
					for (EReference r : node.modelClass.EAllContainments) {
						if (r.name.equals(name.toString))
							return new EObjectDescription(QualifiedName.create(r.name), r, null);
					}
				}
			} 
			else if (context instanceof Link && (context as Link).reference) {
				var list = referenceLinksMap.get(name);
				return if(list.isEmpty) null else list.get(0);
			}
			else if (context instanceof Link && (context as Link).complex) {
				if(reference.name.equals("modelClass")) {
					for(d : complexRefsMap.values)
						if(d.name.equals(name))
							return d;
				}
				else if (reference.equals(ModelPackage.Literals.LINK__SOURCE_REFERENCE)) {
					var qname = QualifiedName.create((context as Link).modelClass.name);
					for(d : complexRefsSourceMap.get(qname))
						if(d.name.equals(name))
							return d;
				} 
				else if (reference.equals(ModelPackage.Literals.LINK__TARGET_REFERENCE)) {
					var qname = QualifiedName.create((context as Link).modelClass.name);
				for(d : targetRefsMap.get(qname))
						if(d.name.equals(name))
							return d;
				}	
			}
			else if (reference.name.equals("modelAttribute")) {
				var owner = getDiagramElement(context);
				if (owner.modelClass == null || owner.modelClass.name == null)
					return null;
				var list = attributesMap.get(QualifiedName.create(owner.modelClass.name));
				for(d : list)
					if(d.name.equals(name))
						return d;
				return null;
			}
			else if(context instanceof Anchor) {
				var owner = crawlUp(context, ModelPackage.Literals.NODE) as Node;
				var qname = QualifiedName.create(owner.modelClass.name);
				if(context.direction == AnchorDirection.OUTGOING) {
					for(d : outgoingRef.get(qname))
						if(d.name.equals(name))
							return d;
					return null;
				}
				else if(context.direction == AnchorDirection.INCOMING) {
					for(d : incomingRef.get(qname))
						if(d.name.equals(name))
							return d;
					return null;
				}
			}

			return eClassMap.get(name);
		}
	}

}
